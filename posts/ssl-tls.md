---
title: 'SSL/TSL'
date: '2021-10-16'
---

## SSL/TSLとは

SSL(Secure Sockes Layer)
TLS(Transport Layer Security)

暗号化・改ざん検知・認証機能を提供するトランポート層(L4)の上位層に位置するプロトコル
一般にTCPの上で動作する場面が多い

### バージョン

SSL 1.0、2.0、3.0
TLS 1.0(SSL 3.1)、TLS 1.1(SSL 3.2)、 TLS1.2(SSL 3.3)などのバージョンがある
現在はTLS 1.3が仕様策定中のステータス

※ SSL1.0とSSL2.0は重大な脆弱性が発見されているため使用禁止とされている
※ SSL3.0もIETFにより使用禁止とされた

### SSLとTLSの違い

TLSはSSLの次世代規格、一般的に現在SSLと言われる時も実質TLSを指していることがほとんど
SSLとTLSの違いはバージョンの違いだけで、TLSがメジャーになりしばらく経っているのでSSLと呼ぶのはやめようという動きもある

### SSL/TLSの利用場面

HTTPS専用と思われているが、SSL/TLSはトランスポート層で動作するため、上位のアプリケーションプロトコルとは独立して動く
よってFTPやSMTPをSSL/TLSで暗号化する**FTP over SSL**や**SMTP over SSL**も存在する

※ **SSHを利用してリモートマシン間でファイルを転送するSCPやSFTPはSSLとは関係がないので注意**

### 常時SSL化

現在はサイト全体の通信をSSL/TLSによって秘匿化するのがトレンドとなっている
GoogleChromeなどのブラウザでは常時SSL化に対応していないサイトは警告が表示されるため事実上対応が必須となっている

### SSL/TLSを利用する効果

以下の3つの脅威からデータを保護することができる
* 盗聴
* 改ざん
* なりすまし

#### 盗聴

通信路に重要なデータがそのままの状態(平文)で流れていたら盗み見ることができる
SSL/TLSではクライアントとサーバ間の通信を暗号化し、盗聴しても内容がわからないようにすることができる

#### 改ざん

通信経路においてデータが書き換えられてしまう脅威に対して、改ざんを検知する機能を提供する
通信するデータから計算した**メッセージダイジェスト(MD)**をデータと合わせて送信する(ハッシュ値ともいう)

受け取った方はデータからMDを計算すると同時に、添付されてきたMDを比較し改ざんされていないかを確認する
つまり比較して同じ値になっていなければ途中で改ざんされている可能性があるとわかる

### なりすまし

通信している相手が本当に意図した相手なのかを認証によって確かめる

例えば訪問したWebサイトが本当に正しいサイトか確認するためにはどうしたらいいか
* アクセスしたのがフィッシングサイトかもしれない
* 見た目で判断できないくらい似たサイトを作ることは可能
* ブラウザのブックマーク経由だとしてもそもそもそのサイトがフィッシングサイトだったかもしれない
* 検索ページを経由していてもブラウザが乗っ取られ変な検索エンジンを使わせられているかもしれない
* アドレスバーを見てもDNSサーバーの乗っ取りやDNSキャッシュポイズニングの被害を受けているかも

こういった可能性を排除するためにSSL/TLSでは**ディジタル証明書**を使用する
データを送信する前に送信先にディジタル証明書を要求し、送信先が正しい相手かどうかを確認する

### SSLハンドシェイク

通信を開始する際にSSL/TLSではTCPを利用するため、まずTCPの3ウェイハンドシェイク(SYN → SYN/ACK → ACK)を行う
こうしてTCPセッションを確立する

その後でSSLハンドシェイクを行い、ここで取り決めた情報をもとにメッセージを暗号化して通信する

#### ①サポートしている暗号スイートの提示

クライアントから自身がサポートしているSSL/TLSバージョンや暗号スイートをサーバ側に提示する
**暗号スイート** : 鍵交換の方法/サーバ認証の方法/暗号化の方法/MACアルゴリズムなどをまとめた呼び方

つまりクライアント側から「この暗号化アルゴリズムなら使えます」とサーバ側に知らせている

#### ②通信相手の証明

サーバからクライアントに**サーバ証明書**を提示する
クライアントはそれを用いて本当に本物のサーバと通信しているか確認する

具体的には受け取ったサーバ証明書を検証(**ルート証明書**で復号してMD比較)し本物のサーバであることを確認している

#### ③共通鍵の交換

メッセージの暗号化の際に使用する**共通鍵**をクライアントからサーバへ送信する
注意点としてここでは共通鍵をそのものを交換するわけではなく、あくまで共通鍵の素材(**プリマスターシークレット**)を交換する

実際に使用する共通鍵はこのプリマスターシークレットとclient random / server randomを混ぜて作成する

共通鍵は誰かに知られるわけにはいかないのでプリマスターシークレットは**公開鍵**で暗号化して送る
受け取ったサーバは**秘密鍵**で復号してプリマスターシークレットを取り出して利用する

#### ④最終確認

SSL/TLSによる暗号化通信における暗号化方式(AES、DES、3DESなど)を宣言し、ハンドシェイクの終了を互いに確認する

以降はSSLハンドシェイクの手続きによって生成した共通鍵を使用して暗号/復号を行い、安全に通信を行うことになる

## SSL/TLSに関わる技術

SSL/TLSを実現するにあたって様々な技術が組み合わされて使われている

### 共通鍵暗号

対称鍵暗号/秘密鍵暗号とも呼ばれる
データの暗号化および復号化に共通の鍵を使うのが特徴

送信者と受信者が前もって同じ鍵を共有している必要がある
(AES、DES、3DESなどが有名)

共通鍵をどうやって秘匿に送信するかという**鍵配送問題**を、公開鍵暗号で解決している

#### ブロック暗号

平文をブロックごとに分割し、ブロック内のビットを攪拌することで暗号化する方式
ブロック長よりも長い平文はモードという仕組みを使う(ECB/CBC/CFB/CTR/OFB/GCMなどがある)

例としてCBCでは初期化ベクトル(IV: Initialization Vector)というものが使用される
ブロックの平文が同じだったとしてもIVの値により各ブロックが暗号文では異なる値になるようにしている
(内部的には各ブロックの暗号文を連鎖させていくことで同じ平文ブロックから同じ暗号文ブロックが生成されないようにしている)

#### ストリーム暗号

鍵から生成した擬似乱数ビット列と平文を**ビット単位**で排他的論理和(XOR)ととることで暗号文とする暗号化方式
ビット単位で計算できるためブロック暗号より高速だが、ブロック暗号の方が安全と言われている
(リアルタイム性が求められるなどの場合はこちらが適しているケースもある)

### 公開鍵暗号

非対称暗号と呼ばれる
データの暗号鍵と復号鍵に異なる鍵を使用する暗号化方式
(RSAや楕円曲線暗号などが有名)

外部からは秘密にしておくべき秘密鍵と外部に向けてオープンな公開鍵がある
この二つをセットで**キーペア**と呼ぶ

送信者は受信者の公開鍵を用いてデータを暗号化し送信する
受信側で秘密鍵を用いて復号しデータを取り出す

* 公開鍵で暗号化 → 秘密鍵で復号(秘匿: 秘密鍵をもっている相手しか復号できないデータをやり取りすることができる)
* 秘密鍵で暗号化 → 公開鍵で復号(署名: 復号した公開鍵に対応する秘密鍵を持った相手からのデータであることが保証される)

### ハッシュ関数

いかなる長さのデータを入力しても固定長の擬似乱数データを出力する関数

入力データをハッシュ関数にかけて出力されるデータを**メッセージダイジェスト**もしくは**フィンガープリント**、**ハッシュ値**という

とあるデータ同士を比較する際にそれぞれのオリジナルを比較しても良いが、データサイズが大きければ時間がかる
そのためメッセージダイジェスト同士を比較する方法がとられる
（どんなサイズのデータからも同じサイズのメッセージダイジェストが算出される)

ハッシュ化は**不可逆変換**でハッシュ値から元のハッシュ化前のデータを算出することはできない

ハッシュ関数は異なる入力データに対して同じハッシュ値をとる可能性がある(**ハッシュ値の衝突**)
ただし、この確率は極めて低く普通は気にする必要はない

有名なハッシュ関数にMD5、SHA-1、SHA-2(SHA-256/SHA-512)などがある

### ディジタル署名(電子署名)

SSL/TLSではディジタル証明書(サーバ証明書/クライアント証明書)を使用して自身を証明するために使われる
信頼できる第三者(**認証局**)にAさんがAさんであることをディジタル署名で認めてもらう

署名の対象データをハッシュ化し、署名者の秘密鍵で暗号化しておく(ディジタル署名)
検証者は公開されている公開鍵を用いてディジタル署名を復号し、同時に対象データをハッシュ化した値と比較、一致することを確認する

#### 暗号スイート

SSL/TLSで通信するときにクライアント/サーバ間でやり取りされる
具体的には利用可能な鍵交換の方法、サーバ認証の方法、暗号化の方法、MACアルゴリズムをまとめたもの

双方が許容する暗号スイートが一致しない場合はSSL/TLS通信は失敗する

一例として「ECDHE-ECDSA-AES128-GCM-SHA256」のような暗号スイートがあるが、
これは「鍵交換の方式-サーバ認証方式-暗号化の方法-暗号化モード-MACアルゴリズム」という表記になっている

**鍵交換の方法**
SSL/TLSハンドシェイクの際にプリマスターシークレットの交換にて使用するアルゴリズム
(例: RSA、DH、ECDHなど)

**サーバ認証の方法**
SSL/TLSにおいてサーバの認証を行うためのアルゴリズム
(例: RSA、DSS、ECDSAなど)

**暗号化の方法**
SSL/TLSの暗号化通信に使用する共通鍵のアルゴリズム
(例: AES、RC4、3DES、CAME、LLIA、AESGなど)

**MACアルゴリズム**
SSL/TLSの暗号化通信時に使用するメッセージ認証コード(MAC)アルゴリズム
これをもとに改ざん検知を実施する
(例: MD5、SHA-1、SHA-2、AEAD)

### メッセージ認証コード(MAC)

MAC: Message Authentication Codeはデータを認証するための短い情報のこと
データが発行元から改変されていないことを確認するためのデータ

1. 送信側で本体データをもとにチェック用のデータを作成し送信する
2. 受信側で受け取ったデータをもとにチェック用のデータを作成する
3. 送信側で作成したチェック用データと受信側で作成したチェック用データを付け合わせする

ディジタル署名では公開鍵暗号方式の仕組みを用いて改ざんの確認を行う
メッセージ認証では共通鍵方式やハッシュ関数を使ってチェック用のデータを作成する

HMAC(Keyed-Hashing for Message Authentication): SHA-2などのハッシュ関数を使用する
CMAC(Cipher-hased Messeage Authentication Cade): 共通鍵暗号のブロック暗号(AESなど)を用いる

### ディジタル証明書

ディジタル証明書はSSL/TLSにおいて認証機能を実現するために利用される
署名前証明書、ディジタル署名のアルゴリズム、ディジタル署名で構成される

ディジタル証明書には階層構造があり、証明書の位置する階層によって呼び方が異なる
最も上位に位置する証明書を**ルート証明書**といい、反対に最も下位に位置する証明書を**エンドエンティティ証明書**と呼ぶ
サーバ証明書やクライアント証明書はエンドエンティティ証明書になる

#### ルート証明書

ルート認証局が発行した自身の身元を証明する証明書のこと
ディジタル証明書によるサーバやクライアントの認証はルート証明書を信頼する前提で成り立っている

ルート認証局はベリサインに代表される公的な機関や企業が運営しており、厳正な審査を受けてそれをパスする必要がある
さらにその認証局が証明書を発行した「子」認証局があり、さらに「孫」認証局があり...と階層構造になっている
下位の認証局(CA)は上位の認証局に証明書を発行してもらうことでその信頼性を担保している

例えばサーバ証明書の場合、クライアントではあらかじめ信頼できる認証局のルート証明書を保持している
そしてSSL/TLSの通信の際にサーバから受け取った証明書からたどっていき保持しているルート証明書が見つかった場合に相手を信頼する仕組み

## SSL/TLS通信の流れ

### ①サポートしている暗号スイートの提示

クライアントから自身がサポートしているSSL/TLSバージョンや暗号スイートをサーバ側へ提示する
サーバ側ではお互いにサポートしているものから選び、クライアントに「これを使おう」と返す

### ②サーバ証明書と公開鍵を送る

サーバはサーバ証明書をクライアントに送付する(公開鍵が含まれている)

### ③サーバ証明書の確認と共通鍵の生成

クライアントはサーバ証明書をもとに本物のサーバと通信できているかを確認する
具体的にはサーバ証明書の階層をたどっていき、自身に登録されているルート証明書と照合する

照合の結果、通信相手が意図したサーバであることが確認できたら共通鍵を生成する

### ④共通鍵をサーバの公開鍵で暗号化して送る

生成した共通鍵(の元であるプリマスターシークレット)を公開鍵で暗号化してサーバに送信する

サーバ側では自身の秘密鍵で復号し、共通鍵を取り出す

### ⑤SSL/TLS通信の開始

両者が共通鍵を持つことができたのでそれを使って暗号化通信を行う
やり取りされるデータはメッセージ認証コード(MAC)を付与して通信途中で改ざんされていないかチェックする

**SSLハンドシェイクのシーケンス**

ClientHello(→)こんな暗号スイート使えるよ
ServerHello(←)この暗号スイートにしよう

ServerCertificate(←任意)サーバの証明書を送ります
Server Key Exchange(←任意)共通鍵の素の交換用の情報を送ります
Certificate Request(←任意)クライアント証明書をください
Server Hello Done(←)サーバ側の情報は全て送ったよ

Client Certificate(→任意)クライアントの証明書送ります
Client Key Exchange(→)共通鍵の素をそちらの公開鍵で暗号化して送るよ
Client Verify(→任意)クライアント証明書を送ります

Change Cipher Spec(→)この暗号化アルゴリズムで暗号化しよう
Finished(→)準備OK
Change Cipher Spec(←)暗号化アルゴリズムについて了解しました
Finished(←)準備OK

## ディジタル証明書

ディジタル証明書は以下の構成になっている

* 署名前証明書 : サーバ及びサーバ所有者の情報、コモンネーム(CN)や有効期限、公開鍵などが含まれている
* ディジタル署名のアルゴリズム : 一方向ハッシュ関数、これを用いてディジタル署名を作成する
* ディジタル署名 : 署名前証明書をハッシュ関数でハッシュ化し、さらに認証局の秘密鍵で暗号化したもの

証明書の構造は標準化されており、代表的なものはX.509と呼ばれる
実際はこれをDER形式でエンコードしたバイナリ(derファイル)として保存したり、
base64形式でエンコードしたテキストファイル(pemファイル)として保存する

pem形式はWindowsでは関連づけされていないが、拡張子をcerやcrtに変更すると証明書ビューアに関連づけて開くことができる

### サーバ証明書を発行する流れ

Webサーバを起動してSSL/TLSサービスを起動させるだけではダメで、証明書を用意したり認証局に申請したりなどが必要

1. SSL/TLSサーバでキーペアを生成する
2. 生成したうち秘密鍵を用いてCSR(Certificate Signing Request)を作成、認証局に提出
3. 認証局の審査を受ける
4. 認証局から発行されたサーバ証明書をSSL/TLSサーバにインストールする

### 証明書の検証方法

まず証明書のIssuerという項目に記載された発行者の証明書を確認する
もし証明書が信頼する証明書でなければ、さらにその発行者の証明書を確認する、この操作をルート証明書もしくは信頼する証明書に辿り着くまで繰り返す
(証明書チェーンという)

### ワイルドカード証明書

あるドメインの一階層したのサブドメイン全てで有効になるようなものをワイルドカード証明書という
ワイルドカード証明書では*.example.jpのような記載になっておりhoge.example.jpやwww.example.jpなどに共通して利用できる

### Let’s Encrypt

米国の非営利団体であるISRG（Internet Security Research Group）による無料のSSLサーバ証明書
90日間有効なDV(DDomain Validation) SSL証明書を2つの認証方式(ドメイン認証とDNS認証)で提供している

ACME（Automated Certificate Management Environment）プロトコルと呼ばれるSSL証明書を自動発行する仕組みを利用している